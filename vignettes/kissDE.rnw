\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{geometry}
\usepackage[english]{babel}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dvips]{graphicx}
\usepackage{color}
\usepackage{alltt}
\usepackage{dsfont}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{listings}

\newcommand{\kde}{\textsc{kissDE}}
\newcommand{\kp}{\textsc{KisSplice}}

\hypersetup{
    	   pdfborder={0 0 0},
}

%\VignetteIndexEntry{kissDE Reference Manual}
\title{kissDE Reference Manual}
\author{}


\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle



\section{Abstract}
\kde was developed in the scope of NGS data post-processing, and in particular RNA-seq data. Many experiments include several biological conditions to decypher their influence on the present transcripts. After one have found a collection of variants by analyzing its reads, it is natural to focus on the biological relevance of what is in the list, which can be thousands of variants. \kde helps to sort interesting variants by testing if a variant is specific to a condition. It takes as input read counts for each variant in each replicate of each condition, and outputs a p-value (adjusted for multiple testing) and a metric (Df/Dpsi) which indicates the magnitude of the effect.\\
The term "variant" applies both to genomic variants and splicing variants. In both cases, the same gene gives rise to two RNA molecules, which differ in their sequence.\\
When a gene gives rise to more than two RNA molecules, we assume the set of all transcripts can be split in two groups.
In the case of alternative splicing, the two groups are: the ones that include the exon of interest, and the ones that exclude the exon of interest.
In the case of genomic polymorphism, the two groups are: the ones that contain the first allele, the ones that contain the second allele.\\
The statistical framework is similar to DESeq. The main difference is that for gene expression, one value per gene is provided, although in the case of \kde, dealing with polymorphism or alternative splicing means providing two values: one per variant. Read counts are pre-processed, several models are tested to fit the data and keep the best to perform the LRT and output the p-value jointly to several metrics and flags. The model and the package's workflow are further detailed in \textbf{section 3}.

\section{Prerequisites}
\subsection{Dependencies}
Aurélie
\subsection{Data}
\kde is meant to work on pairs of alternative variants that have been quantified across different conditions. Such variants can be found with different bioformatics workflows, variant callers,... Among them, \kde was at first designed to work with \kp, which performs local assembly on RNA-seq data in order to find and quantify alternative variants. When one have found a list of variants with \kp, we provide a function within this packages that makes easy to convert \kp's fasta files into a format than can be used for testing with \kde. Although \kde is a tool from \kp's suite, it can be used independantly from \kp with counts for each variants obtained with any other method.\\
The user must keep in mind that \kde was designed to work with at least one replicate for each condition, which means that the minimal input is variants quantified for 4 different individuals, each couple representing a condition. There can be more replicates and more conditions, it is also not mandatory to have an equal number of replicates in each condition.\\
For running \kde, you need to give as input a table of raw counts and a vector describing your number of conditions and replicates.
You can provide your own table of counts, or simply use \kp's output. Raw table of counts format is described at \textbf{section 4.1: Input data}.
%Since version 1.2.0 you have also the choice to input a kissplice2refgenome file or a discoSNP file.

\section{kissDE content}
schema du workflow
\subsection{Options}
\subsection{Normalization}
\subsection{Statistical tests}
\subsubsection{Estimation of dispersion}
\subsubsection{Models}
\subsubsection{Likelihood ratio test}
correction multiple tests
\subsection{Filtering}
\subsection{Magnitude of the effect}

\section{Examples}
\subsection{Input data}
\subsubsection{KisSplice}
ref manual - possible for all types (0, 1, 2, 3)
\subsubsection{Counts table: howto}
\subsection{Data visualization}
plots qualityControl
+ plot models dans la fonction ppale
\subsection{kissDE on SNP data}
vecteur condition
lancement test
export données
results
\subsection{kissDE on alternative splicing data}
vecteur condition
lancement test
export données
results

\section{Session info}
Aurélie
% section biblio ?
\end{document}

\section{What kissDE does}

\section{Prerequisites}


%\begin{enumerate}
% \item You must build a table with the counts of the pairwise variants you want to test. This can be done with \texttt{kissplice2counts}.
% \item Once you have provided a table of counts on your own or created by \texttt{kissplice2counts}, you must provide a vector that describes the experimental conditions
%\end{enumerate}

\subsection{Providing a table of counts}
For running kissDE, you need to give as input a table of raw counts and a vector describing your number of conditions and replicates.
You can provide your own table of counts, or simply use KisSplice's output. Since version 1.2.0 you have also the choice to 
input a kissplice2refgenome file or a discoSNP file.



\subsubsection{You work with your own data: data frame format}
kissDE is a tool from KisSplice's suite but you still can use it independantly if you have counts for your variants coming from another method. kissDE's main function takes a table of counts as input. It must be provided as a data frame such as:\\
\begin{verbatim}
head(dataframekissDE)
              X0   X1   X2  X3  X4  X5
1     variation1  127  955 897 302 443
2     variation1  80   17  20   5   2
3     variation2 1543  450 599 400 325
4     variation2 1201    1   5   4   0
5     variation3  221 1192 881 479 587
6     variation3  219   83  48  50  37
...
\end{verbatim}
\begin{itemize}
 \item One variation is represented by two lines, one for each variant.
 \item Each line has a first column (X0) with the name of the variation, a second (X1) with the size of the variant, then all others columns (X2... Xn) show counts for each replicate in each condition for the variant.\\
 For instance \verb|X1|:Cond1Repl1, \verb|X2|:Cond1Repl2...
\end{itemize}

\subsubsection{You work with KisSplice/kissplice2refgenome/discoSNP's output: kissplice2counts function}
If you use output files from KisSplice, you can directly import your counts using \texttt{kissplice2counts} function.
To create an object with \texttt{kissplice2counts}, you will probably use one of these lines:\\

  \texttt{myCounts <- kissplice2counts('./path/results\_Kissplice\_typeX.fa')}\\

or \\
  \texttt{myCounts <- kissplice2counts('./path/results\_Kissplice\_typeX.fa',pairedEnd=TRUE)}\\

or\\
  \texttt{myCounts <- kissplice2counts('./path/results\_Kissplice\_typeX.fa',pairedEnd=TRUE, counts=2)}\\

\begin{itemize}
\item with for instance \texttt{results\_Kissplice\_typeX.fa} the file containing your Type1 (alternative splicing events) file from KisSplice,
 \item  with \texttt{pairedEnd = TRUE} if you have paired-end reads, \texttt{pairedEnd = FALSE} else, 
 \item  and \texttt{counts = 2} option if you have counts like this in KisSplice output:\\
 \texttt{AS1\_1|SB1\_2|ASSB1\_1|S1\_0...} for upper path and \texttt{AB1\_3...} for lower,\\
      or no counts option otherwise ( \texttt{C1\_1|C2\_6...} type).
\end{itemize}

The table you have created in \texttt{myCounts} helps to convert information provided in KisSplice output into a table of counts per event that will be used for the tests.\\
Events are pairwise, made of 2 variants (typically an exon retained and an exon skipped fort 2 variants in alt. splicing, or two genomic variants if you work with SNPs or indels). So now you'd like to test if you have some differentially enriched variants between your conditions (i.e. is my skipped exon isoform is more present in my condition 1 and on the contrary the other isoform more present in my condition 2).

\paragraph{Alpha options : discoSNP and kissplice2refgenome\\}
If you have run DiscoSNP to find SNPs in your data, you can also use kissDE. You have to put \texttt{discoSNP} option to \texttt{TRUE} in kissplice2counts and in the main function.\\
If you have used kissplice2refgenome on top of your KisSplice's run, you can directly use the kissplice2refgenome's output in kissDE. You have to put the option \texttt{k2rg} to \texttt{TRUE}. This option is particularly interesting if you have an (annotated) reference genome.


\subsection{Providing an experimental conditions vector}
The experimental conditions vector helps to make the link between the conditions you want to test and the files input in KisSplice. For instance, if in KisSplice you have entered 4 fasta/q files in this order:\\

\texttt{-r firstCondition\_Replicate1 -r firstCondition\_Replicate2\\
-r secondCondition\_Replicate1 -r secondCondition\_Replicate2}\\

In this case there are only have two conditions and to replicates for each conditions. Any number of replicates is allowed, even an unequal number across conditions, provided there are at least 2 replicates per condition. In the example your condition vector will look like :\\

\texttt{myConditions <- c("condition1","condition1","condition2","condition2")}\\

What is important is that this vector matches the order of what you have input. Probably it will be clearer if you give \texttt{condition1} and \texttt{condition2} a more descriptive name. For instance :

\texttt{myConditions <- c("control","control","treatment","treatment")}\\
 

\paragraph{If you have paired end data, and entered in KisSplice for instance:\\}

\texttt{-r firstCondition\_Replicate1\_file1 -r firstCondition\_Replicate1\_file2
-r firstCondition\_Replicate2\_file1  -r firstCondition\_Replicate2\_file2 
-r secondCondition\_Replicate1\_file1 -r secondCondition\_Replicate1\_file2
-r secondCondition\_Replicate2\_file1 -r secondCondition\_Replicate2\_file2}

Then you must \textbf{not} have a condition vector like this:\\

\texttt{myConditions <- c("condition1","condition1", "condition1","condition1",\\
"condition2","condition2","condition2","condition2")}\\

as \texttt{pairedEnd} option must have been already switched to \texttt{TRUE} in \texttt{kissplice2counts}, you can provide a condition vector like this one:\\ 

\texttt{myConditions <- c("condition1","condition1","condition2","condition2")}\\

The function \texttt{diffExpressedVariants} performs the test, based on generalised linear models. Basically it needs only the counts (\texttt{myCounts} table) you got from \texttt{kissplice2counts} function, and your \texttt{myConditions} vector.

\subsection{Launching diffExpressedVariants}
To start the analyse you just have to run \texttt{diffExpressedVariants}, for a first run we recommand to put \texttt{pvalue=1}, your final table will also include non significant events. In case you want to analyse why some of your favorite genes are not in the head of the list. Important options of \texttt{diffExpressedVariants} are explained below.\\

\texttt{finalTable <- diffExpressedVariants(myCounts,myConditions,pvalue=1)}
\begin{itemize}
 \item You will obtain in finalTable the list of the events with their pvalue and the size of the effect (in the column \texttt{DeltaF/DeltaPSI}). 
  \item The difference of length between the two variants is also provided, which can be interesting if you are dealing with alternative splicing or indels. A difference of length which is not a multiple of 3 is particularly interesting if located in a CDS.
 \item Events with low counts ($<$ 10 by default) in at least n-1 conditions over n are flagged in the column \texttt{LowCounts} (more details below).
\end{itemize}





\section{Counts normalization}
Counts are normalized with the default normalization methods provided in the \textbf{DESeq} package. In particular, if some replicate has been sequenced with a higher depth, this is properly taken care of.

\section{Filtering low counts before the tests}
 If global counts for both variants are too low (option \texttt{filterLowCountsVariants}), the event is not tested.
Here we present two examples to explain how \texttt{filterLowCountsVariants} option works. Let's assume that there are two conditions and two replicates (rep1 and rep2) per condition. \texttt{filterLowCountsVariants} has its default value: 10.\\

\begin{tabular}{r|c|c|c}
  \hline
   & Condition 1 & Condition 2& Sum by variant \\
  \hline
  Variant 1 &	rep1:1, rep2:2 & rep1:3, rep2:2& 1+2+3+2=8 $<$ 10  \\
 Variant 2 &	rep1:8, rep2:0 & rep1:1, rep2:0& 8+0+1+0=9 $<$ 10 \\
  \hline
\end{tabular}
\paragraph{}In this first example the two variants have global counts less than 10, this event will be used to compute the overdispersion, but will not be used to compute the models. It will neither appear in the final table. On the contrary in the second example below, the event will be taken into account for tests.\\

\begin{tabular}{r|c|c|c}
  \hline
   & Condition 1 & Condition 2& Sum by variant \\
  \hline
  Variant 1 &	rep1:11, rep2:15 & rep1:3, rep2:2&  11+15+3+2=31 $>$ 10 \\
 Variant 2 &	rep1:8, rep2:0 & rep1:1, rep2:0& 8+0+1+0=9 $<$ 10 \\
  \hline
\end{tabular}


\section{Tests}
Our statistical analysis adopts the framework of count regression with Negative Binomial distribution as in standard RNA-Seq analysis. We consider 2-way design with interaction with \textit{alleles} and \textit{experimental conditions} as main effects. Following the Generalized Linear Model framework, the expected intensity of the signal is denoted by $\lambda_{ij}$ and is decomposed such that
$$
\log \lambda_{ij} = \mu + \alpha_{i} +\beta_{j} + \left(\alpha \beta \right)_{ij}
$$
where $\mu$ is the local mean expression of the gene that contains the SNP, $\alpha_{i}$ the effect of allele $i$ on expression, $\beta_{j}$ the contribution of condition $j$ to total expression and $\left(\alpha \beta \right)_{ij}$ the interaction term. The target hypothesis is $H_0:\{\left(\alpha \beta \right)_{ij}=0\}$ (no interaction between allele and condition) that is tested using a Likelihood Ratio Test with a 5\% FDR to account for multiple testing.

\section{Delta PSI / Delta f computation}
\subsection{Magnitude of the effect}
When a gene is found to be differentially spliced between two conditions, or an allele is found to be differentially present in two populations, one concern which remains is to quantify the magnitude of this effect.
Indeed, especially in RNAseq, where some genes are very highly expressed (and hence have very high read counts), it is often the case that we detect significant (p<0.05) but weak effects. 

When dealing with genomic variants, we quantify the magnitude of the effect using the difference of allele frequencies between the two conditions.
When dealing with splicing variants, we quantify the magnitude of the effect using the difference of Percent Spliced In (PSI) between the two conditions.
These two measures turn out to be equivalent and can be summarized using the following formula :

$$PSI \:=\: f  \:=\:  \frac{\#counts\_variant_1}{\#counts\_variant_1 + \#counts\_variant_2} $$ \\
$DeltaPSI \:=\: PSI_{cond1} - PSI_{cond2}$ \\
$Deltaf \:=\: f_{cond1} - f_{cond2}$

%The  percent spliced in (PSI) is not used to perform tests but we output it to give information about the magnitude of the effect. Indeed, with highly expressed genes pvalues can be significant even if for smal switches of variant presence, because there are a lot of reads to assess it. Intuitively percent spliced in are the ratio of the quantity of counts witnessing the presence of the inclusion isoform over the total counts sum for both isoforms. The delta PSI is simply the subtraction of the PSI calculated for each condition. A high delta PSI (in absolute) shows that the main isoform has changed between the two conditions.\\ 
\subsection{Correction with respect to the length}
In the case where the two variants do not have the same length (genomic indels or splice variants), then this formula is not correct, since the abundance of the longer variant will be over-estimated. We therefore need to introduce a correction factor.
This correction factor is not the same if the counts that were input to kissDE correspond to a- junction reads only or b- junction reads + exonic reads.
%However this value is biased because the inclusion isoform is longer (in case of indels and alternative splicing) and more reads are prone to mapping on it. That is why we introduced a correction of the counts to compute the delta PSI:
\begin{itemize}
 \item if the results from KisSplice were obtained with \texttt{--counts} option by default (\texttt{--counts 0} which gives \texttt{...|C1\_25|C2\_1|C3\_14.....} in the headers) :\\
  $\Rightarrow$ no information is provided about junction counts. In this case:
 \begin{enumerate}
 \item a correction factor is calculated, taking into account the apparent length of the each path (which is where the reads can actually map):\\
   $correctFactor\:=\: \frac{length\_upper\_path + readLength - 2 \times overlap + 1}{length\_lower\_path + readLength - 2\times overlap + 1}$ with :
 \begin{itemize}
  \item \texttt{upper\_path} which is always the inclusion isoform (the longer one)/\texttt{lower\_path} which is the exclusion isoform,
  \item \texttt{overlap}: which is set to \texttt{k+1} (the \texttt{k} value used in KisSplice) and \texttt{readLength} (default: 75) are two option in \texttt{diffExpressedVariants} to estimate the area where read can map on each path
   \end{itemize}
            \item counts of the upper path are corrected because we expect to find more reads mapped on it:\\
            $\#counts\_upper\_path \:=\:  \frac{\#counts\_upper\_path}{correctFactor} $
 \end{enumerate}
 \item if there is no read overlapping the junction, we only divide by 2 the number of reads seen on the upper path (as globally the counts on the upper path are twice the the counts on the lower path because there are two junctions in the first versus only one in the second), 
 \item if the results were obtained with \texttt{--counts 2} in KisSplice (which gives \texttt{...|AS1\_12|AB1\_7|S1\_0|ASSB1\_1 ou |AB1\_13|.....} in the headers) \textbf{see KisSplice manual about --counts option}:\\
 $\Rightarrow$ information about junction counts is provided: on the upper path, the number of reads mapped is equal to \texttt{AS+AB-ASSB} (\texttt{ASSB} reads are counted twice, in \texttt{AS} or \texttt{AB} and in \texttt{ASSB})
  \item if there are reads on ASSB junction, the idea is to divide by a bit less than two (having counts over the spliced exon means it is quite small):
  \begin{enumerate}
%    \item \texttt{comptages\_upper\_path <- AS+AB-ASSB }
    \item before correction : $counts\_upper\_path \:=\: AS+AB-ASSB $
    \item after correction : $counts\_upper\_path\:=\:\frac{comptages\_upper\_path}{2-\frac{ASSB}{AS+SB-ASSB}}$
  \end{enumerate}
 \end{itemize}
 
\subsection{Computation}
The delta PSI/delta f is computed:
 \begin{itemize}
\item individual (per replicate) PSI are calculated:\\
after the counts are corrected, if counts for both upper and lower path are too low ($<10$) the individual PSI is not computed.
\item Then mean PSI are computed:\\
they are the mean of individual PSI for one condition. If more than the half of individual PSI were not calculated at the latter step, the mean PSI is not computed.
\item Finally, we output delta PSI:\\
unless one of the mean PSI of a condition could not be estimated. Delta PSI is calculated subtracting one condition PSI from another. This does not always follow the order of the conditions you entered in the first place. To know the order, you must report to the output file, delta PSI are calculated subtracting the first condition appearing in the header from the one after.
\end{itemize}


\section{Low counts flag and final table}
If in at least $n-1$ conditions (be $n$ the number of conditions $\geq 2$) an event has low counts (option \texttt{filagLowCountsConditions}) it is flagged (\texttt{TRUE} in the last column of the output).\\
In the example table, we can see that the counts are quite contrasted, variant 1 seemed more expressed in condition 1 and variant 2 in condition 2. Moreover, this event has enough counts for each variant not to be filtered out by \texttt{filterLowCountsVariants} option:\\

\begin{tabular}{r|c|c|c}
  \hline
   & Condition 1 & Condition 2& Sum by variant \\
  \hline
  Variant 1 &	rep1:1, rep2:0 & rep1:6, rep2:7&  1+0+6+7=14 $>$ 10 \\
 Variant 2 &	rep1:5, rep2:3 & rep1:1, rep2:2&  5+3+1+2=11 $>$ 10 \\
  \hline
 Sum by condition &	\textbf{9} $<$ 10 	&16 $>$ 10 & \\ 	
  \hline
\end{tabular}

\paragraph{}However, in $n-1$ (here 1) condition, the global count for one condition is less than 10 (9 for condition 1), so \texttt{flagLowCountsConditions} option will classify this in event in \texttt{'Low\_Counts'} column with a \texttt{TRUE} value. 