\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage[english]{babel}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dvips]{graphicx}
\usepackage{color}
\usepackage{alltt}
\usepackage{dsfont}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage[square,numbers]{natbib}
\usepackage{color}   %May be necessary if you want to color links
\usepackage{hyperref}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
}

\newcommand{\kde}{\textsc{kissDE}}
\newcommand{\kp}{\textsc{KisSplice}}
\newcommand{\krg}{\textsc{KisSplice2refgenome}}

\hypersetup{pdfborder={0 0 0}}

%\VignetteIndexEntry{kissDE Reference Manual}
\title{kissDE Reference Manual}
\author{}


\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle



\begin{abstract}

In the context of RNA-seq, NGS gives access to important sequencing depth and enables to study different transcripts isoforms coming  from the same gene. In eukaryotes, many genes are not only spliced (exons are kept to build a mRNA) but also undergo alternative splicing, where combinations of exons in a gene yield different transcripts that correspond to alternative isoforms. Through this process a single gene can produce a collection of RNA molecules. Many experiments include several biological conditions to decypher their influence on the present transcripts. After one have found a collection of variants by analyzing its reads, it is natural to focus on the biological relevance of what is in the list, which can be thousands of variants. 

\kde~helps to sort interesting variants by testing if a variant is specific to a condition. \kde~is a R-package for the analysis of RNA-seq data in the context of alternative splicing. It is the the continuation of \kp~, a software a designed to retrieve alternative transcripts in RNA-seq data.  Even if it has been customed for \kp~, it may also be used independently with data from other software that reports alternative variants from sequencing data. \kde~detects genomic variants like exon specific events, indels, SNP/mutations, that are specific to a biological condition. 
When a gene gives rise to more than two RNA molecules, we assume the set of all transcripts can be split in two groups.
In the case of alternative splicing, the two groups are: the ones that include the exon of interest, and the ones that exclude the exon of interest.
In the case of genomic polymorphism, the two groups are: the ones that contain the first allele, and the ones that contain the second allele.\\
The statistical framework is similar to DESeq. The main difference is that for gene expression, one value per gene is provided, although in the case of \kde, dealing with polymorphism or alternative splicing means providing two values: one per variant. To perform the condition-specific analysis, \kde~implements the statistical framework in a user-friendly manner. Read counts are pre-processed, several models are tested to fit the data and keep the best to perform the LRT and output the p-value jointly to several metrics and flags. 

\end{abstract}

\newpage
\tableofcontents

<<echo=false>>=
options(continue=" ")
@

\newpage
\section{Prerequisites}
%\subsection{Data}
\subsection{Use case}
%just explain the format (4 lines... and the type of question/biological objects)
\kde~is meant to work on pairs of alternative variants that have been quantified across different conditions. It can deals with single nucleotide variant (SNV) or alternative splicing.\\
The input count data to \kde~may come from \kp\cite{Sacomoto2012}, \krg or any other sofware if the counts are transformed into the data structure required for the package.
If you use output files from \kp~or \krg, you can directly import your counts using \texttt{kissplice2counts} function.\\
The user must keep in mind that \kde~was designed to work with at least one replicate for each condition, which means that the minimal input contain the variants quantified for 4 different samples, each couple representing a condition. There can be more replicates and more conditions. It is also not mandatory to have an equal number of replicates in each condition.\\

\subsection{Install and load \kde}
In a R session, you must first install Bioconductor.
<<installBC,eval=FALSE, fig=FALSE>>=
source("http://bioconductor.org/biocLite.R")
@
Then you can install the \kde~package from Bioconductor.
<<install,eval=FALSE, fig=FALSE>>=
biocLite("kissDE")
@
Finally, load it.
<<library, fig=FALSE>>=
library(kissDE)
@


\subsection{Quick start}

Here we present the basic commands for the analysis of alternative splicing events with \kde. These commands require the output file of \kp. 
To load other types of input file, please refer to section \ref{subsec:input}.\\
Here we assume that we have two conditions with two biological replicates and the RNA-Seq libraries are single-end.

<<quick_start, fig=FALSE, eval=FALSE>>=
counts <- kissplice2counts("output_kissplice.fa")
conditions <- c(rep("condition_1", 2), rep("condition_2", 2))
qualityControl(counts, conditions)
results <- diffExpressedVariants(counts, conditions)
write.csv(results$finalTable, file = "kissDE_output.csv")
@

\subsection{Time and requirements}
% ordre de grandeur des temps de calcul
% matériel nécessaire pour faire tourner kissDE


\section{\kde's workflow}
%\subsection{Options} maybe in the end ?

\begin{figure}[h]
  \centering
  \includegraphics[width=0.7\textwidth]{Workflow_KissDE.png}
  \caption{\textbf{Schema of the workflow.}}
\end{figure}


\subsection{Input data}
\label{subsec:input}
\kde's input is a table of raw counts and a vector describing the number of conditions and replicates. Three options are possible, either to work directly with \kp's output or with \krg's output or to provide a table of counts.


\subsubsection{You work with your own data (without \kp): table of counts format}
\label{subsubsec:input_count}
Let's assume we work with two conditions $(condition_1, condition_2)$ and two replicates.
The input table has to be in the following format:
<<tablecounts_howto, fig=FALSE>>=
fpath1 <- system.file("extdata", "table_counts_alt_splicing.txt", 
                      package="kissDE")
tableCounts <- read.table(fpath1, head = TRUE)
head(tableCounts)
@
\begin{itemize}
 \item \textbf{Lines:} one variation is represented by two lines, one for each variant. For instance for SNVs, one allele is described in the first line, and the other in the second line. For alternative splicing events, the inclusion form and the exclusion forms has one line each.
\item \textbf{Columns:}
\begin{itemize}
\item Each line has a first column (\texttt{eventsName}) with the name of the variation.
\item The second column (\texttt{eventsLength}) is the size of the variant. If this size is unknown, the value can be set to 0. Note that the size is used only in the case of alternative splicing, to give the indication wether the size difference due to the switch from one isoform to the other is a multiple of 3 or not (thus induces a switch in the ORF).
\item  All others columns (\texttt{cond1rep1, cond1rep2, cond2rep1, cond2rep2}) represent read counts of a variant in each sample. For instance, \verb|cond1rep1| is the counts corresponding to reads from the first replicate in $condition_1$, \verb|cond1rep2| is the counts of reads sequenced for replicate 2 in $condition_1$, \verb|cond2rep1| and \verb|cond2rep2| are counts for replicates 1 and 2 of $condition_2$.
\end{itemize}
\end{itemize}


\subsubsection{Input table from \kp~ output}
\label{subsubsec:input_ks}
\kde~can be used directly on \kp~output which is in fasta format as follow :
<<kissplice_format, echo=FALSE, echo=FALSE>>=
headfasta <- system.file("extdata", "head_output_kissplice_alt_splicing_fasta.txt",
                      package="kissDE")
writeLines(readLines(headfasta))
@
By having a look at the 4 first lines, we can see that the fasta file is structurated as follows:
events are reported in 4 lines, the two first represent one variant of the splicing event (or one allele of the SNV), the last two lines the other variant (or the other allele). For each variant, we have a header begining with the symbol '>' and the sequence. The headers contain useful information:
\begin{itemize}
\item elements shared by the headers of the two variants:
\begin{itemize}
  \item \texttt{bcc\_68965|Cycle\_4} is the event's ID
  \item \texttt{Type\_1} means that the sequences contains a splicing event
\end{itemize}
\item elements that are specific to a variant:
\begin{itemize}
  \item \texttt{upper\_path\_length\_112} and \texttt{lower\_path\_length\_82} give the length of the nucleotide sequences. Upper path and lower path are a denomination for the representation of each variant in \kp's graph. For alternative splicing events, the upper path represent the inclusion form and the lower path the exclusion form.
  \item \texttt{AS1\_1|SB1\_1|S1\_0|ASSB1\_0|...} and \texttt{AB1\_21|AB2\_12|AB3\_12|AB4\_2|AB5\_5|...} summarizes the counts found by KisSplice during the step where reads are used to perform quantification of each variant detected. Here we are in the case where \kp was run with the option \texttt{counts} set to 2. For the upper path, we have 4 counts by sample, and for the lower path, we have 1 count by sample. There are 8 set of counts because we gave 8 files in input to \kp. Each count correspond to the reads coming from each file that could be mapped on the variant, in the order they have been passed to \kp.
\end{itemize}
\item NB: the rank is a deprecated measure.
\end{itemize}

%TODO : show a figure to explain the different type of reads (AS, SB, ASSB, AB and S)

\kde~can be used on any type output by \kp~(0: SNV, 1: alternative splicing events, 2: indels,...). The user must refer to \kp~manual for further questions about \kp~format and output.\\

It is possible to obtain a table of counts to perform the tests of \kde~directly from \kp's output, using the function \texttt{kissplice2counts}.
<<kissplice2counts_howto, fig=FALSE>>=
fpath2 <- system.file("extdata", "output_kissplice_alt_splicing.fa",
                      package="kissDE")
myCounts <- kissplice2counts(fpath2, counts = 2, pairedEnd = TRUE)
names(myCounts)
head(myCounts$countsEvents)
@

\begin{itemize}
\item \textbf{Lines:} one variation is represented by two lines, one for each variant. For instance for SNVs, one allele is described in the first line, and the other in the second line. For alternative splicing events (like in this example), the inclusion and the exclusion form have one line each.
\item \textbf{Columns:}
\begin{itemize}
\item Each line has a first column (\texttt{events.names}) with the name of the variation, from \kp~notation.
\item The second column (\texttt{events.length}) is the size of the variant, extracted from \kp~header. It gives the indication wether the size difference due to the switch from one isoform to the other is a multiple of 3 or not (thus induces a switch in the ORF).
\item  All others columns (\texttt{counts1, counts2, counts3, counts4}) show counts for each replicate in each condition for the variant.
\end{itemize}
~
\end{itemize}
The counts are extracted from \kp~header and depending on the parameters used to run \kp~different \texttt{kissplice2counts} options must be set.\\
First, the \texttt{counts} option must correspond to the \texttt{counts} parameter given to \kp. The possible values are 0, 1 or 2 (0 being the default value for both \texttt{kissplice2counts} and \kp).\\
Then, the user should also specify the \texttt{pairedEnd} option. If RNA-Seq libraries are single-end, \texttt{pairedEnd} should be set to \texttt{FALSE}. And if RNA-Seq libraries are paired-end, this option should be set to \texttt{TRUE}. In this case, \texttt{kissplice2counts} function expect the counts of the paired-end reads to be next to each other. If it is not the case, the option \texttt{order} should be used to indicate the actual order of the reads.

%TODO : give an example of the order option ?


\subsubsection{Input table from \krg~ output}
\label{subsubsec:input_krg}
The \texttt{kissplice2counts} function also allows the user to directly load data output from \krg~by adding the \texttt{k2rg} options. This tool allow the annotation of the alternative splicing events. It assign each event to the gene it map to and to a type of alternative splicing event: Skipped Exon (SE), Intron Retention (IR), Alternative Donor (AltD), Alternative Acceptor (AltA). Users must refer to \krg~manual for further questions about \krg~format and output.
<<kissplice2counts_k2rg_howto, fig=FALSE>>=
fpath3 <- system.file("extdata", "output_k2rg_alt_splicing.txt", 
                      package="kissDE")
myCounts_k2rg <- kissplice2counts(fpath3, counts = 2, 
                                  pairedEnd = TRUE, k2rg = TRUE)
names(myCounts_k2rg)
head(myCounts_k2rg$countsEvents)
@
The count table obtained by running this command has exactly the same structure as explained in section \ref{subsubsec:input_ks}.\\


The KisSplice2refgenome output contains the information of the type of splicing events. So it is possible to choose the event we want to analyse. The two options \texttt{keep} and \texttt{remove} allow the user to indicate the type of splicing events to analyse or to remove from the analysis. These 2 options take a character vector indicating the types of events to keep or remove. The events names should come from this list : deletion, insertion, IR, ES, altA, altD, altAD, alt, unclassified. In the \texttt{remove} option, the event name MULTI can also be used. By default, all types of events are analysed.\\
If we want to analyse only cassette exon events (ie: a single exon is skipped or included), the following command should be used :
<<kissplice2counts_k2rg_ESonly_howto, fig=FALSE>>=
myCounts_k2rg_ES <- kissplice2counts(fpath3, counts = 2, 
                                     pairedEnd = TRUE, k2rg = TRUE, 
                                     keep = c("ES"), remove = c("MULTI"))
@

%TODO : check if it works also on SNV


\subsubsection{Condition vector}
The second item to prepare is the condition vector that describes the inter order of the columns in the count table. Following our example of section \ref{subsubsec:input_count}, the condition vector will be:
<<conditionVector_howto, fig=FALSE>>=
myConditions <- c(rep("condition_1", 2), rep("condition_2", 2))
@
because the counts have been put in an order that represents first the two replicates of $condition_1$, then the two replicates of $condition_2$.\\
If the count table was loaded from \kp~or~\krg output, the condition vector must contain the samples in the same order they were given to \kp.\\

\underline{WARNING:} To run \kde, all conditions must have replicates. So each condition must at least be present twice in the condition vector.


\subsection{Quality Control}
\kde~contain a function that allow the user to control the quality of the data and to check if no error was done at the data loading step. This data quality assessment are essential and should be done before the differential analysis.\\
The function \texttt{qualityControl} get in input the count table and the condition vector. It produce 2 plots :
\begin{itemize}
\item{heatmap of the sample-to-sample distances}
\item{principal component analysis (PCA)}
\end{itemize}
<<qualityControl_howto, include=FALSE, fig=TRUE>>=
qualityControl(myCounts, myConditions)
@
\begin{figure}[h]
  \centering
  \includegraphics[page=1,width=0.45\textwidth]{kissDE-qualityControl_howto.pdf}
  \includegraphics[page=2,width=0.45\textwidth]{kissDE-qualityControl_howto.pdf}
  \caption{\textbf{Quality control plots.} Left: Heatmap of the sample-to-sample distances. Right: Principal Component Analysis.}
\end{figure}

With theses plots, the user can see the similarities and the differences between the analyzed samples. We expect to cluster together the replicates of the same condition. If a sample is contaminated or has an abnormality that will influence the differential analysis, it will certainly not be clustered as expected. The user can then go back to the quality control of the raw data to solve the problem or decide to remove the sample from the analysis.\\

The created figures can be saved by setting the \texttt{storeFigs} option to \texttt{TRUE} or to the path where the figures are to be stored.


\subsection{Differential analysis}
When the data is loaded, we can run the differential analysis using the \texttt{diffExpressedVariants} function. This function needs 2 arguments : the count table and the condition vector.
<<diffExpressedVariants_howto, fig=FALSE>>=
myResults <- diffExpressedVariants(myCounts, myConditions)
@

Three options are available to change the filters or the flags applied by the \texttt{diffExpressedVariants} function :
\begin{itemize}
  \item \texttt{pvalue} : By default, the pvalue threshold to output the significant events is set to 1. So all variants are output in the final table. The user can set this option to a numeric value between 0 and 1. Be aware that by setting \texttt{pvalue} to 0.05, only events that have been identified as significant between the conditions with a FDR > 5\% will be present in the final table.
  \item \texttt{filterLowCountsVariants} : With this option, users can change the threshold to filter low expressed events before testing (like explained in section \ref{subsec:filter}). By default, \texttt{filterLowCountsVariants} is equal to 10.
  \item \texttt{flagLowCountsConditions} : With this option, users can change the threshold to flag low expressed events (like explained in section \ref{subsec:flag}). By default, \texttt{flagLowCountsConditions} is equal to 10.
\end{itemize}
The \texttt{output} option is only relevant when the table count was loaded from the \k2rg output. For explaination of this option see section \ref{subsubsec:merge}

The output of \texttt{diffExpressedVariants} is a list of 5 objects :
<<myResults_description, fig=FALSE>>=
names(myResults)
@
\texttt{uncorrectedPVal} and \texttt{correctedPval} are numeric vectors containing p-values before and after correctio for multiple testing. \texttt{resultFitNBglmModel} is a data frame containing the results of the fitting od models to the data.\\
For explanations on \texttt{finalTable} and \texttt{f/psiTable} objects, see respectively section \label{subsubsec:finaltable} and section \label{subsubsec:psitable}.

% TODO: explain discoSNP option ? Camille


\subsection{Export results}

\subsubsection{Final table}
\label{subsubsec:finaltable}
The \texttt{finalTable} object is the main output of the \texttt{diffExpressedVariants} function.
<<finaltable_description, fig=FALSE, echo=FALSE>>=
print(head(myResults$finalTable, n = 3), row.names = FALSE)
@
This table contains the following informations:\\
\begin{itemize}
  \item \texttt{ID} column allows user to identify the events. An event is represented by one row in the table.
  \item \texttt{Length\_diff} represents the length of the variable part length in a splicing event. It is the length difference between the upper and lower path. This column is not relevant for SNVs. 
  \item \texttt{Variant1\_condition\_1\_repl1\_Norm} and following columns summarize the counts for each replicate of each variant after normalization with DESeq2. The first half represent the first variant of each event, the second half the second variant.
  \item \texttt{Adjusted\_pvalue} corresponds to p-values computed and adjusted.
  \item \texttt{Deltaf/DeltaPSI} summarizes the magnitude of the effect.
  \item \texttt{lowcounts} flags low counts events as described in section \ref{subsec:flag}. This colum is equal to \texttt{FALSE} if the events has no low counts.
\end{itemize}
Events are sorted by p-values and then by magnitude of effect (based on their absolute values), so that the top candidates for further investigation/validation appear at the beginning of the list.

A tab-delimited file of these results can be exported using the \texttt{write.table} function :
<<finaltable_write, fig=FALSE, eval=FALSE>>=
write.table(myResults$finalTable, file = "results_table.tab", 
            quote = FALSE, sep = "\t", row.names = FALSE)
@

Users can export only events passing some thresholds on adjusted p-value and/or Deltaf/DeltaPSI using the \texttt{which} function.\\
If we want to write in the output file only events with the adjusted p-value < 0.05 and the Deltaf/DeltaPSI absolute value > 0.10, we can use the following commands :
<<finaltable_thresholds_write, fig=FALSE, eval=FALSE>>=
myResultsFilteredTable <- 
  myResults$finalTable[which(myResults$finalTable$Adjusted_pvalue < 0.05 & 
                             abs(myResults$finalTable$`Deltaf/DeltaPSI`) > 0.10),]
write.table(myResultsFilteredTable, file = "results_table.tab", 
            quote = FALSE, sep = "\t", row.names = FALSE)
@


\subsubsection{Merge between final table and \krg~output}
\label{subsubsec:merge}
If the table counts was loaded from the \krg~output with \texttt{kissplice2counts} function, running the \texttt{diffExpressedVariants} will write a file merging results of differential analysis with \krg~data. By default, this file will be created in the working directory and will be named \textit{kissDE\_result}. The file name and directory can be changed using the option \texttt{output} in \texttt{diffExpressedVariants} function :
<<krg_output_write, fig=FALSE, eval=FALSE>>=
myResults_k2rg <- diffExpressedVariants(myCounts_k2rg, myConditions, 
                                        output = "merge_k2rg_kissDE_results.tab")
@


\subsubsection{f/PSI table}
\label{subsubsec:psitable}
The \texttt{f/psiTable} output contains the f/PSI value for each event in each sample :
<<fPSItable_description, fig=FALSE, echo=FALSE>>=
head(myResults$`f/psiTable`, n = 3)
@
The computation of the f/PSI value is explained in section \label{subsec:psi}.\\

This table can be useful to carry out downstream analysis or to produce specific plots (like heatmap on f/PSI events). To use these informations with external tools, this table can be written in a tab-delimited file :
<<fPSItable_write, fig=FALSE, eval=FALSE>>=
write.table(myResults$`f/psiTable`, file = "psi_table.tab", 
            quote = FALSE, sep = "\t", row.names = FALSE)
@



\section{\kde's theory}

In this section, we detail the different steps of the \kde~main function: \texttt{diffExpressedVariants}.\\
\begin{figure}[h]
  \centering
  \includegraphics[width=0.5\textwidth]{Workflow_diffExpressedVariants.png}
  \caption{\textbf{The different steps of the \texttt{diffExpressedVariants} function.}}
\end{figure}


\subsection{Normalization}
Counts are normalized with the default normalization methods provided in the \textbf{DESeq2}\cite{Love2014} package. The goal of the normalization step is to remove technical factors that could influence the differential analysis. By using \textbf{DESeq2} normalization, we correct for library size, because the sequencing depth can vary between samples.


\subsection{Estimation of dispersion}
First, we choose a model to describe the counts distribution. When working with biological replicates, the Poisson distribution's variance parameter is in general not flexible enough to describe the data, because replicates add several sources of variance. This overdispersion is often modeled using a Negative Binomial distribution, which we chose for this package. However, due to numerical instabilities associated with the estimation of Negative Binomial parameters, we use a model selection approach to determine which model is the best to handle the overdispersion parameter $\phi$. We first estimate a model without overdispersion using the \textsc{glmnet} package (model $\mathcal{M}(\phi=0)$). We then consider two different estimation methods for the parameter $\phi$, namely a global estimation approach using the package \textsc{aod} (model $\mathcal{M}(\phi=\phi_{\text{global}})$), and a variant-specific parameter using the \textsc{DSS} package (model $\mathcal{M}(\phi=\phi^i_{\text{DSS}})$. A BIC is used to choose the best model out of the three.

%TODO : rewrite this part...


\subsection{Pre-test filtering}
\label{subsec:filter}
If global counts for both variants are too low (option \texttt{filterLowCountsVariants}), the event is not tested.
The rationale behind this filter is to speed up the analysis and gain statiscal power.
Here we present two examples to explain how \texttt{filterLowCountsVariants} option works. Let's assume that there are two conditions and two replicates (rep1 and rep2) per condition. \texttt{filterLowCountsVariants} has its default value: 10.\\

\begin{table}[h]
\centering
\begin{tabular}{c|c|c|c|c|c}
    &\multicolumn{2}{c|}{Condition 1} &  \multicolumn{2}{c|}{Condition 2}&  Sum by variant\\
    & replicate 1  & replicate 2 & replicate 1 & replicate 2 & \\ \hline
 Variant 1 &	11 &         15  & 3           &   2         & 11+15+3+2=31 $>$ 10 \\
 Variant 2 &	8  &           0 &        1    &            0& 8+0+1+0=9 $<$ 10 \\
\end{tabular}
\caption{}
\label{tab:filter1}
\end{table}

\paragraph{}In the first example (Table \ref{tab:filter1}), the two variants have global counts less than 10, this event will be used to compute the overdispersion, but will not be used to compute the models. It will neither appear in the result table. In contrast in the example shown in Table \ref{tab:flag1}, the event will be tested.\\


\subsection{Model}
Then we design two models to take into account interactions with \textit{variants} (SNVs or alternative isoforms) and \textit{experimental conditions} as main effects. We  use the Generalized Linear Model framework. The expected intensity $\lambda_{ijk}$ can be written as following:

$$\mathcal{M_0}:\:\:\log \lambda_{ijk} = \mu + \alpha_{i} +\beta_{j} $$
$$\mathcal{M_1}:\:\:\log \lambda_{ijk} = \mu + \alpha_{i} +\beta_{j}+ \left(\alpha \beta \right)_{ij}$$ 

where $\mu$ is the local mean expression of the transcript that contains the variant, $\alpha_{i}$ the effect of variant $i$ on the expression, $\beta_{j}$ the contribution of condition $j$ to the total expression, and $\left(\alpha \beta \right)_{ij}$ the interaction term. 

To avoid singular hessian matrices while fitting models, pseudo-counts (\textit{i.e.}, systematic random allocation of ones) were considered for variants showing many zero counts.


\subsection{Likelihood ratio test}
To select between $\mathcal{M_0}$ and $\mathcal{M_1}$, we perform a Likelihood Ratio Test (LRT). In the null hypothesis $H_0:\{\left(\alpha \beta \right)_{ij}=0\}$, there is no interaction between variant and condition. For events where $H_0$ is rejected, the interaction term is significant to explain the count's distribution, which leads to conclude to a differential usage of a variant across conditions. The LRT is performed with one degree of freedom, which  corresponds to the supplementary interaction parameter. P-values are then adjusted with a 5\% false discovery rate (FDR) following a Benjamini-Hochberg procedure to account for multiple testing, 


\subsection{Flagging low counts}
\label{subsec:flag}
If in at least $n-1$ conditions (be $n$ the number of conditions $\geq 2$) an event has low counts (option \texttt{filagLowCountsConditions}) it is flagged (\texttt{TRUE} in the last column of the output).\\
In the example table \ref{tab:flag1}, we can see that the counts are quite contrasted, variant 1 seemed more expressed in condition 1 and variant 2 in condition 2. Moreover, this event has enough counts for each variant not to be filtered out by \texttt{filterLowCountsVariants} option:\\

\begin{table}[h]
\centering
\begin{tabular}{c|c|c|c|c|c}
    &\multicolumn{2}{c|}{Condition 1} &  \multicolumn{2}{c|}{Condition 2}&  Sum by variant\\
    & replicate 1  & replicate 2 & replicate 1 & replicate 2 & \\ \hline
 Variant 1 &	1 &         0  & 6       &   7         &  1+0+6+7=14 $>$ 10 \\
 Variant 2 &	5 &           3 &        1    &           2&  5+3+1+2=11 $>$ 10 \\
 \hline
  Sum by condition &\multicolumn{2}{c|}{\textbf{9} $<$ 10 }	&\multicolumn{2}{c|}{16 $>$ 10} & \\
\end{tabular}
\caption{}
\label{tab:flag1}
\end{table}

\paragraph{}However, in $n-1$ (here 1) condition, the global count for one condition is less than 10 (9 for condition 1), so \texttt{flagLowCountsConditions} option will classify this in event in \texttt{'Low\_Counts'} column with a \texttt{TRUE} value. This event may be interesting because it has the potential to be found as differential. However, it will be hard to validate it experimentally.


\subsection{Magnitude of the effect}
\label{subsec:psi}
%just the main computation, particular correction wrt the length will come with examples
When a gene is found to be differentially spliced between two conditions, or an allele is found to be differentially present in two populations, one concern which remains is to quantify the magnitude of this effect.
Indeed, especially in RNA-seq, where some genes are very highly expressed (and hence have very high read counts), it is often the case that we detect significant (p<0.05) but weak effects. 

When dealing with genomic variants, we quantify the magnitude of the effect using the difference of allele frequencies (Delta f) between the two conditions.
When dealing with splicing variants, we quantify the magnitude of the effect using the difference of Percent Spliced In (PSI) between the two conditions.
These two measures turn out to be equivalent and can be summarized using the following formula :

$$PSI \:=\: f  \:=\:  \frac{\#counts\_variant_1}{\#counts\_variant_1 + \#counts\_variant_2} $$ \\
$$DeltaPSI \:=\: PSI_{cond1} - PSI_{cond2}$$ \\
$$Deltaf \:=\: f_{cond1} - f_{cond2}$$

The deltaPSI/deltaf is computed:
\begin{itemize}
\item individual (per replicate) PSI/f are calculated:\\
after the counts are corrected, if counts for both upper and lower path are too low ($<10$) the individual PSI/f is not computed.
\item Then mean PSI/f are computed:\\
they are the mean of individual PSI/f for one condition. If more than half of individual PSI/f were not calculated at the previous step, the mean PSI/f is not computed.
\item Finally, we output deltaPSI/deltaf:\\
Unless one of the mean PSI/f of a condition could not be estimated. DeltaPSI/deltaf is calculated subtracting one condition PSI/f from another. This does not always follow the order of the conditions you entered in the first place. To know the order, you must report to the output file, deltaPSI/deltaf are calculated subtracting the first condition appearing in the header from the one after. DeltaPSI/deltaf absolute value varie between 0 and 1, with values close to 0 indicating low effect and values close to 1 strong effect.
\end{itemize}

% TODO: size correction
%       PSI with exonic reads


\section{Case studies}

\subsection{\kde~on SNV data}
RNA-seq data can be used to study SNVs (SNPs, mutations, RNA editing) in expressed regions of the genome. Such SNVs can be detected and reported by \kp. Here is an example of an analysis of SNPs done with \kde~on RNA-seq data from the human GEUVADIS project\cite{Lappalainen2013}.

\subsubsection{Dataset}
The dataset used in this example comes from the human GEUVADIS project. We selected two samples containing of pool of Toscans (TSC) individuals and two samples containing a pool of Central Europeans (EUR).\\
The data is paired-end. So each sample consists of 2 files. In total, 8 files have been used as KisSplice input : 4 files representing the two TSC samples and 4 files representing the two EUR samples. Paired-end files from a same sample have been input following each other.\\
The output file of \kp~is a fasta file that stores SNVs found in the dataset :

<<snv_kissplice_data, fig=FALSE, echo=FALSE>>=
headfasta <- system.file("extdata", "head_output_kissplice_SNV_fasta.txt",
                      package="kissDE")
writeLines(readLines(headfasta))
@

By having a look a the 4 first lines, we can see that the fasta file has a structure similar to what was shown for alternative splicing event in section \ref{subsubsec:input_ks}.\\
Events are reported in 4 lines, the two first represent one allele of the SNV, the two last the other allele. Thus the sequences only differ from each other by their SNV content.\\
Because \kp was run with the default value for the \texttt{counts} option (0), the counts have the following format \texttt{C1\_x|C2\_y|...|Cn\_z}. In this example, there are 8 counts because we input 8 files. Each count correspond to the reads coming from each file that could be mapped on the variant, in the order they have been passed to \kp. This information is particularly important in kissDE since it represents the counts used for the test.\\
The quality scores come after the counts for each read set following a \texttt{Q}.

\subsubsection{Load data}
The first step is to convert this fasta file into a format that will be used in kissDE's main function for testing. This can be done as follows:
<<snv_counts, fig=FALSE>>=
fileIn <- system.file("extdata", "output_kissplice_SNV.fa", package = "kissDE")
myCounts_SNV <- kissplice2counts(fileIn, pairedEnd=T)
head(myCounts$countsEvents)
@
We are in the case of paired-end RNA-seq data, this information must be passed to the function so that counts from both files can be summed, with option \texttt{pairedEnd=T}.\\
For a description of the count table, see section \ref{subsubsec:input_ks}.\\

To be able to perform the differential analysis, we must provide a vector that describes what is our experimental plan. In this example, we have two replicates of TSC and two replicates of EUR. So we construct a vector:
<<snv_condition, fig=FALSE>>=
myConditions_SNV <- c(rep("TSC",2), rep("EUR",2))
@

\subsubsection{Quality control}
Before running the differential analysis, it is recommended to check if no error was done at the loading step with the \texttt{qualityControl} function.
<<qualityControl_SNV, include=FALSE, fig=TRUE>>=
qualityControl(myCounts_SNV, myConditions_SNV)
@
\begin{figure}[h]
  \centering
  \includegraphics[page=1,width=0.45\textwidth]{kissDE-qualityControl_SNV.pdf}
  \includegraphics[page=2,width=0.45\textwidth]{kissDE-qualityControl_SNV.pdf}
  \caption{\textbf{Quality control plots on SNV data.} Left: Heatmap of the sample-to-sample distances on SNV data. Right: Principal Component Analysis on SVN data.}
\end{figure}

We can see that on both plot, the replicates of the same condition seem to be more similar between them than to the samples of the other condition. On the heatmap, the samples of the same condition cluster together. On the PCA plot, the first principal component clearly discriminate the samples of the 2 conditions.

\subsubsection{Differential analysis}
We can now call the main function of the package that computes the statistical test. \kde~outputs a list of events that passed the p-value threshold:
<<snv_test, fig=FALSE>>=
myResult_SNV <- diffExpressedVariants(myCounts_SNV, myConditions_SNV)
head(myResult_SNV$finalTable, n = 3)
@
The format of this result table was describe in section \ref{subsubsec:finaltable}.

The event at the top of the list shows a low p-value (4.975013e-09) and a very contrasted $\Delta f$ (-0.9258) close to the maximum value (1 in absolute). This SNP would typically be population specific. One allele is present in the Toscan population, the other in the European population. The $\Delta f$  of this event is not equal to 1 because the data are pooled (3 individuals in each sample).

\subsubsection{Export results}
We consider as significant the events that have a p-value adjusted lower than 5\%. We can export the result passing this threshold :
<<snv_export_result, fig=FALSE, eval=FALSE>>=
myResultsFilteredTable_SNV <- 
  myResults_SNV$finalTable[which(myResults_SNV$finalTable$Adjusted_pvalue < 0.05),]
write.table(myResultsFilteredTable_SNV$finalTable, 
            file = "final_table_significants.tab", 
            quote = FALSE, sep = "\t", row.names = FALSE)
@


\subsection{\kde~on alternative splicing data}
This second example treat the case of differential analysis of alternative splicing events found by \kp and \krg.

\subsubsection{Dataset}
The data used in this vignette to show an example of analysis of alternative splicing comes from ENCODE\cite{Djebali2012}. The chosen samples are from a neuroblastoma cell line, SK-N-SH, with or without a retinoic acid treatment. Each condition is composed of two biological replicates. The data are paired-end.\\
\kp~has been used to analyse these two conditions. Then, the type 1 results from KisSplice were mapped to the reference genome with STAR and analyzed with \krg. This tool allow the annotation of the alternative splicing events. It assigned each event to the gene it map to and to a type of alternative splicing event: Skipped Exon (SE), Intron Retention (IR), Alternatid Donor (AltD), Alternative Acceptor (AltA). For any question on these tools, please refer to the manual.

The first step is to load the output of \krg. It is a tab delimited file that store the annotated alternative splicing events found in the dataset. Here is an extract of this file :

<<AS_data, fig=FALSE, echo=FALSE>>=
fileInAS <- system.file("extdata", "output_k2rg_alt_splicing.txt", 
                        package = "kissDE")
exampleK2RG <- read.table(fileInAS)
names(exampleK2RG) <- NULL 
print(head(exampleK2RG[,c(1:11)], 3), row.names = FALSE)
@

One line corresponds to one alternative splicing event. The data presented above is an extract of the \krg original file which contains more columns.
%TODO : explain the format ?

\subsubsection{Load data}
The \texttt{kissplice2count} function allows to transform this text format into a format compatible with \kde's main function for testing (see section \ref{subsubsec:input_krg}). The \texttt{k2rg} option must be set to \texttt{TRUE} to indicate that the file comes from \krg and not from \kp. As explained earlier, because these samples are paired-end, this information must be given to the \texttt{kissplice2count} function.\\
The \texttt{counts} option must be set to the same value as in \kp and \krg to indicate which counts are given in input. In this example, the \texttt{counts} was set to 2 and we decide to not take into account the exonic reads (\texttt{exonicReads = FALSE}).

<<AS_counts, tidy=TRUE, highlight=FALSE, fig=FALSE>>=
fileInAS <- system.file("extdata", "output_k2rg_alt_splicing.txt", 
                        package = "kissDE")
myCounts_AS <- kissplice2counts(fileInAS, pairedEnd = TRUE, k2rg = TRUE, 
                               counts = 2, exonicReads = FALSE)
head(myCounts_AS$countsEvents)
@

To be able to perform the differential analysis, we must provide a vector that describes our experimental plan. In this example, we have two replicates of the SK-N-SH cell line without treatment (SKNSH) and two replicates of the same cell line treated with retinoic acid (SKSNH-RA). So we construct the following vector:
<<AS_condition, fig=FALSE>>=
myConditions_AS <- c(rep("SKNSH",2), rep("SKNSH-RA",2))
@

\subsubsection{Quality control}
Before running the differential analysis, we recommend to check if the data was loaded correctly by running the \texttt{qualityControl} function.
<<qualityControl_AS, include=FALSE, fig=TRUE>>=
qualityControl(myCounts_AS, myConditions_AS)
@
\begin{figure}[h]
  \centering
  \includegraphics[page=1,width=0.45\textwidth]{kissDE-qualityControl_AS.pdf}
  \includegraphics[page=2,width=0.45\textwidth]{kissDE-qualityControl_AS.pdf}
  \caption{\textbf{Quality control plots on alternative data.} Left: Heatmap of the sample-to-sample distances for the alternative splicing dataset. Right: Principal Component Analysis for the alternative splicing dataset.}
\end{figure}

We can see that on both plot, the replicates of the same condition seem to be more similar between them than to the samples of the other condition. On the heatmap, the samples of the same condition cluster together. On the PCA plot, the first principal component clearly discriminate the samples of the 2 conditions.


\subsubsection{Differential analysis}
We can now call the main function of the package that computes the statistical test. \kde~outputs a list of events that passed the p-value threshold:
<<AS_test, fig=FALSE>>=
myResult_AS <- diffExpressedVariants(myCounts_AS, myConditions_AS)
head(myResult_AS$finalTable, n = 3)
@

The event at the top of the list shows a very low p-value (0) and a very contrasted $\Delta PSI$ (-0.8042) close to the maximum value (1 in absolute). This gene is differentially spliced. When the SK-N-SH cell line is treated with retinoic acid, there is a switch of minor/major isoform. 


\subsubsection{Export results}
Two interesting tables can be exported: the result table and the PSI table. Here are the commands to carry out this task:
<<AS_test, fig=FALSE, eval=FALSE>>=
write.table(myResults_AS$finalTable, file = "results_table.tab", 
            quote = FALSE, sep = "\t", row.names = FALSE)
write.table(myResults_AS$`f/psiTable`, file = "psi_table.tab", 
            quote = FALSE, sep = "\t", row.names = FALSE)
@


\section{Session info}
Aurélie

\bibliographystyle{abbrvnat}

\bibliography{bibliography}

\end{document}