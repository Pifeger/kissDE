\documentclass{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage[english]{babel}
\usepackage{multicol}
\usepackage{hyperref}
\usepackage{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[dvips]{graphicx}
\usepackage{color}
\usepackage{alltt}
\usepackage{dsfont}
\usepackage{amsthm}
\usepackage{fancyvrb}
\usepackage{listings}
\usepackage{color}   %May be necessary if you want to color links
\usepackage{hyperref}
\hypersetup{
    colorlinks=true, %set true if you want colored links
    linktoc=all,     %set to all if you want both sections and subsections linked
    linkcolor=blue,  %choose some color if you want links to stand out
}

\newcommand{\kde}{\textsc{kissDE}}
\newcommand{\kp}{\textsc{KisSplice}}
\newcommand{\krg}{\textsc{KisSplice2refgenome}}

\hypersetup{pdfborder={0 0 0}}

%\VignetteIndexEntry{kissDE Reference Manual}
\title{kissDE Reference Manual}
\author{}


\begin{document}
\SweaveOpts{concordance=TRUE}

\maketitle



\begin{abstract}

In the context of RNA-seq, NGS gives access to important sequencing depth and enables to study different transcripts isoforms coming  from the same gene. In eukaryotes, many genes are not only spliced (exons are kept to build a mRNA) but also undergo alternative splicing, where combinations of exons in a gene yield different transcripts that correspond to alternative isoforms. Through this process a single gene can produce a collection of RNA molecules. Many experiments include several biological conditions to decypher their influence on the present transcripts. After one have found a collection of variants by analyzing its reads, it is natural to focus on the biological relevance of what is in the list, which can be thousands of variants. 

\kde~helps to sort interesting variants by testing if a variant is specific to a condition. \kde~is a R-package for the analysis of RNA-seq data in the context of alternative splicing. It is the the continuation of \kp~, a software a designed to retrieve alternative transcripts in RNA-seq data.  Even if it has been customed for \kp~, it may also be used independently with data from other software that reports alternative variants from sequencing data. \kde~detects genomic variants like exon specific events, indels, SNP/mutations, that are specific to a biological condition. 
When a gene gives rise to more than two RNA molecules, we assume the set of all transcripts can be split in two groups.
In the case of alternative splicing, the two groups are: the ones that include the exon of interest, and the ones that exclude the exon of interest.
In the case of genomic polymorphism, the two groups are: the ones that contain the first allele, and the ones that contain the second allele.\\
The statistical framework is similar to DESeq. The main difference is that for gene expression, one value per gene is provided, although in the case of \kde, dealing with polymorphism or alternative splicing means providing two values: one per variant. To perform the condition-specific analysis, \kde~implements the statistical framework in a user-friendly manner. Read counts are pre-processed, several models are tested to fit the data and keep the best to perform the LRT and output the p-value jointly to several metrics and flags. 

\end{abstract}


\tableofcontents

\section{Prerequisites}
%\subsection{Data}
\subsection{Use case}
3 kinds : from kissplice / from k2rg /user
just explain the format (4 lines... and the type of question/biological objects)
%The input count data to KissDE may come from kissplice, DiscoSNP, kissplice2RefGenome or any other sofware if the counts are transformed into the data structure required for the package.
If you use output files from KisSplice or Kissplice2RefGenome, you can directly import your counts using \texttt{kissplice2counts} function.
%\kde~is meant to work on pairs of alternative variants that have been quantified across different conditions. Such variants can be found with different bioformatics workflows, variant callers,... Among them, \kde~was at first designed to work with \kp, which performs local assembly on RNA-seq data in order to find and quantify alternative variants. When one have found a list of variants with \kp, we provide a function within this packages that makes easy to convert \kp's fasta files into a format than can be used for testing with \kde. Although \kde~is a tool from \kp's suite, it can be used independantly from \kp~with counts for each variants obtained with any other method.\\
%The user must keep in mind that \kde~was designed to work with at least one replicate for each condition, which means that the minimal input is variants quantified for 4 different individuals, each couple representing a condition. There can be more replicates and more conditions, it is also not mandatory to have an equal number of replicates in each condition.\\
%For running \kde, you need to give as input a table of raw counts and a vector describing your number of conditions and replicates.
%You can provide your own table of counts, or simply use \kp's output. Raw table of counts format is described at \textbf{section 4.1: Input data}.
\subsection{Install and load \kde}
In a R session, you must first install Bioconductor.
<<installBC,eval=FALSE, fig=FALSE>>=
source("http://bioconductor.org/biocLite.R")
@
Then you can install the \kde~package from Bioconductor.
<<install,eval=FALSE, fig=FALSE>>=
biocLite("kissDE")
@
Finally, load it.
<<library, fig=FALSE>>=
library(kissDE)
@


\section{kissDE's workflow}
schema du workflow
%\subsection{Options} maybe in the end ?

\subsection{Normalization}

Counts are normalized with the default normalization methods provided in the \textbf{DESeq2} package. In particular, if some replicate has been sequenced with a higher depth, this is properly taken care of.


\subsection{Estimation of dispersion}

First, we choose a model to describe the counts distribution. When working with biological replicates, the Poisson distribution's variance parameter is in general not flexible enough to describe the data, because replicates add several sources of variance. This overdispersion is often modeled using a Negative Binomial distribution, which we chose for this package. However, due to numerical instabilities associated with the estimation of Negative Binomial parameters, we use a model selection approach to determine which model is the best to handle the overdispersion parameter $\phi$. We first estimate a model without overdispersion using the \textsc{glmnet} package (model $\mathcal{M}(\phi=0)$). We then consider two different estimation methods for the parameter $\phi$, namely a global estimation approach using the package \textsc{aod} (model $\mathcal{M}(\phi=\phi_{\text{global}})$), and a variant-specific parameter using the \textsc{DSS} package (model $\mathcal{M}(\phi=\phi^i_{\text{DSS}})$. A BIC is used to choose the best model out of the three.


\subsection{Pre-test filtering}

If global counts for both variants are too low (option \texttt{filterLowCountsVariants}), the event is not tested.
The rationale behind this filter is to speed up the analysis and gain statiscal power.
Here we present two examples to explain how \texttt{filterLowCountsVariants} option works. Let's assume that there are two conditions and two replicates (rep1 and rep2) per condition. \texttt{filterLowCountsVariants} has its default value: 10.\\

\begin{table}[h]
\centering
\begin{tabular}{c|c|c|c|c|c}
    &\multicolumn{2}{c|}{Condition 1} &  \multicolumn{2}{c|}{Condition 2}&  Sum by variant\\
    & replicate 1  & replicate 2 & replicate 1 & replicate 2 & \\ \hline
 Variant 1 &	11 &         15  & 3           &   2         & 11+15+3+2=31 $>$ 10 \\
 Variant 2 &	8  &           0 &        1    &            0& 8+0+1+0=9 $<$ 10 \\
\end{tabular}
\caption{}
\label{tab:filter1}
\end{table}

\paragraph{}In the first example (Table \ref{tab:filter1}), the two variants have global counts less than 10, this event will be used to compute the overdispersion, but will not be used to compute the models. It will neither appear in the final result. In contrast in the example shown in Table \ref{tab:flag1}, the event will be tested.\\


\subsection{Model}
 
Then we design two models to take into account interactions with \textit{variants}(SNPs or alternative isoforms) and \textit{experimental conditions} as main effects. We  use the Generalized Linear Model framework. The expected intensity $\lambda_{ijk}$ can be written as following:

$$\mathcal{M_0}:\:\:\log \lambda_{ijk} = \mu + \alpha_{i} +\beta_{j} $$
$$\mathcal{M_1}:\:\:\log \lambda_{ijk} = \mu + \alpha_{i} +\beta_{j}+ \left(\alpha \beta \right)_{ij}$$ 

where $\mu$ is the local mean expression of the transcript that contains the variant, $\alpha_{i}$ the effect of variant $i$ on the expression, $\beta_{j}$ the contribution of condition $j$ to the total expression, and $\left(\alpha \beta \right)_{ij}$ the interaction term. 

To avoid singular hessian matrices while fitting models, pseudo-counts (\textit{i.e.}, systematic random allocation of ones) were considered for variants showing many zero counts.


\subsection{Likelihood ratio test}

To select between $\mathcal{M_0}$ and $\mathcal{M_1}$, we perform a Likelihood Ratio Test (LRT). In the null hypothesis $H_0:\{\left(\alpha \beta \right)_{ij}=0\}$, there is no interaction between variant and condition. For events where $H_0$ is rejected, the interaction term is significant to explain the count's distribution, which leads to conclude to a differential usage of a variant across conditions. The LRT is performed with one degree of freedom, which  corresponds to the supplementary interaction parameter. P-values are then adjusted with a 5\% false discovery rate (FDR) following a Benjamini-Hochberg procedure to account for multiple testing, 


\subsection{Flagging low counts}

If in at least $n-1$ conditions (be $n$ the number of conditions $\geq 2$) an event has low counts (option \texttt{filagLowCountsConditions}) it is flagged (\texttt{TRUE} in the last column of the output).\\
In the example table \ref{tab:flag1}, we can see that the counts are quite contrasted, variant 1 seemed more expressed in condition 1 and variant 2 in condition 2. Moreover, this event has enough counts for each variant not to be filtered out by \texttt{filterLowCountsVariants} option:\\

\begin{table}[h]
\centering
\begin{tabular}{c|c|c|c|c|c}
    &\multicolumn{2}{c|}{Condition 1} &  \multicolumn{2}{c|}{Condition 2}&  Sum by variant\\
    & replicate 1  & replicate 2 & replicate 1 & replicate 2 & \\ \hline
 Variant 1 &	1 &         0  & 6       &   7         &  1+0+6+7=14 $>$ 10 \\
 Variant 2 &	5 &           3 &        1    &           2&  5+3+1+2=11 $>$ 10 \\
 \hline
  Sum by condition &\multicolumn{2}{c|}{\textbf{9} $<$ 10 }	&\multicolumn{2}{c|}{16 $>$ 10} & \\
\end{tabular}
\caption{}
\label{tab:flag1}
\end{table}

\paragraph{}However, in $n-1$ (here 1) condition, the global count for one condition is less than 10 (9 for condition 1), so \texttt{flagLowCountsConditions} option will classify this in event in \texttt{'Low\_Counts'} column with a \texttt{TRUE} value. This event may be interesting because it has the potential to be found as differential. However, it will be hard to validate it experimentally.


\subsection{Magnitude of the effect}
%just the main computation, particular correction wrt the length will come with examples
When a gene is found to be differentially spliced between two conditions, or an allele is found to be differentially present in two populations, one concern which remains is to quantify the magnitude of this effect.
Indeed, especially in RNAseq, where some genes are very highly expressed (and hence have very high read counts), it is often the case that we detect significant (p<0.05) but weak effects. 

When dealing with genomic variants, we quantify the magnitude of the effect using the difference of allele frequencies (Delta f) between the two conditions.
When dealing with splicing variants, we quantify the magnitude of the effect using the difference of Percent Spliced In (PSI) between the two conditions.
These two measures turn out to be equivalent and can be summarized using the following formula :

$$PSI \:=\: f  \:=\:  \frac{\#counts\_variant_1}{\#counts\_variant_1 + \#counts\_variant_2} $$ \\
$DeltaPSI \:=\: PSI_{cond1} - PSI_{cond2}$ \\
$Deltaf \:=\: f_{cond1} - f_{cond2}$

The delta PSI/delta f is computed:
 \begin{itemize}
\item individual (per replicate) PSI are calculated:\\
after the counts are corrected, if counts for both upper and lower path are too low ($<10$) the individual PSI is not computed.
\item Then mean PSI are computed:\\
they are the mean of individual PSI for one condition. If more than the half of individual PSI were not calculated at the latter step, the mean PSI is not computed.
\item Finally, we output delta PSI:\\
Unless one of the mean PSI of a condition could not be estimated. Delta PSI is calculated subtracting one condition PSI from another. This does not always follow the order of the conditions you entered in the first place. To know the order, you must report to the output file, delta PSI are calculated subtracting the first condition appearing in the header from the one after. The more the $\Delta PSI/f$ is close to 1 in absolute, the stronger the effect is. On the contrary a measure close to 0 shows a low effect.
\end{itemize}

%TODO: size correction

\section{Examples}

\subsection{Input data}
\kde's input is a table of raw counts and a vector describing the number of conditions and replicates. Three options are possible, either to work directly with \kp's output or with \krg's output or to provide a table of counts.

\subsubsection{You work with your own data (without \kp): table of counts format}
The proper input table is in the following format:
<<tablecounts_howto, fig=FALSE>>=
fpath1 <- system.file("extdata", "table_counts_alt_splicing.txt", package="kissDE")
tableCounts <- read.table(fpath1, head = TRUE)
head(tableCounts)
@
\begin{itemize}
 \item \textbf{Lines:} one variation is represented by two lines, one for each variant. For instance for SNPs, one allele is described in the first line, and the other in the second line. For alternative splicing events, the inclusion form and the exclusion forms has one line each.
\item \textbf{Columns:}
\begin{itemize}
\item Each line has a first column (\texttt{V1}) with the name of the variation.
\item The second column (\texttt{V2}) is the size of the variant. If this size is unknown, the value can be set to 0. Note that the size is used only in the case of alternative splicing, to give the indication wether the size difference due to the switch from one isoform to the other is a multiple of 3 or not (thus induces a switch in the ORF).
\item  All others columns (\texttt{V3... Vn}) show counts for each replicate in each condition for the variant. For instance, let's assume we work with two conditions $(condition_1, condition_2)$. \verb|V3| is the counts corresponding to reads from the first replicate in $condition_1$, \verb|V4| is the counts of reads sequenced for replicate 2 in $condition_1$, \verb|V5| and \verb|V6| are counts for replicates 1 and 2 of $condition_2$.
\end{itemize}
\end{itemize}
The second item to provide is the condition vector that describes the order in which the counts are given. Following our example, the condition vector will be:
<<conditionVector_howto, fig=FALSE>>=
myConditions <- c(rep("condition_1",2),rep("condition_2",2))
@
because (\texttt{V3, V4, V5, V6}) have been put in an order that represents first two replicates of $condition_1$, then two replicates of $condition_2$.

\subsubsection{\kp}
The user must refer to \kp~manual for any question about \kp~format and output. \kde~can be used on any type output by \kp~(0: SNP, 1: alternative splicing events, 2: indels,...). It is possible to obtain a table of counts to perform the tests of \kde~directly from \kp's output, using the function \texttt{kissplice2counts}.
<<kissplice2counts_howto, fig=FALSE>>=
fpath2 <- system.file("extdata", "output_kissplice_alt_splicing.fa", package="kissDE")
myCounts <- kissplice2counts(fpath2, counts = 2, pairedEnd = TRUE)
names(myCounts)
head(myCounts$countsEvents)
@
\begin{itemize}
\item \textbf{Lines:} one variation is represented by two lines, one for each variant. For instance for SNPs, one allele is described in the first line, and the other in the second line.
 For alternative splicing events (like in this example), the inclusion form and the exclusion forms has one line each.
\item \textbf{Columns:}
\begin{itemize}
\item Each line has a first column (\texttt{events.names}) with the name of the variation, from \kp~notation.
\item The second column (\texttt{X1}) is the size of the variant, extracted from \kp~header. It gives the indication wether the size difference due to the switch from one isoform to the other is a multiple of 3 or not (thus induces a switch in the ORF).
\item  All others columns (\texttt{X2, X3, X4, X5}) show counts for each replicate in each condition for the variant.
\end{itemize}
The counts are extracted from \kp~header.
%|C_...
%|ASSB_...
\end{itemize}

% parler des données pairées ??

\subsubsection{\krg}
%TODO

\subsection{Quality Control plots}

\kde~contain a function that allow the user to control the quality of the data and to check if no error was done at the data loading step. This data quality assessment are essential and should be done before the differential analysis.\\
The function \texttt{qualityControl} produce 2 plots :
\begin{itemize}
\item{dendrogram}
\item{heatmap of the sample-to-sample distances}
\end{itemize}
<<qualityControl_howto, include=FALSE, fig=TRUE>>=
qualityControl(myCounts,myConditions)
@
\begin{figure}[ht]
\centering
\includegraphics[page=1]{kissDE-qualityControl_howto.pdf}
\caption{Dendrogram of samples.}
\end{figure}

\begin{figure}[ht]
\centering
\includegraphics[page=2]{kissDE-qualityControl_howto.pdf}
\caption{Heatmap of the sample-to-sample distances.}
\end{figure}

With theses plots, the user can see the similarities and the differences between the analyzed samples. If a sample is contaminated or has an abnormality that will influence the differential analysis, it will certainly not be clustered as expected. The user can then go back to the quality control of the raw data to solve the problem or decide to remove the sample from the analysis.\\

The created figures can be saved by setting the \texttt{storeFigs} option to \texttt{TRUE} or to the path where the figures are to be stored.


\subsection{kissDE on SNP data}
RNA-seq data do not only provide an insight in alternative splicing, it can also be used to study SNPs in expressed regions of the genome. Such SNPs can be detected and reported by KisSplice. Here we use an extract of sequences from the Geuvadis project. We selected two Toscans (TSC) individuals and two Central Europeans (EUR).
A pair of files represent each replicate (whom have been paired-end sequenced), so eight files have been used for KisSplice input, 4 files representing the two TSC, followed by 4 files representing the two EUR. Paired-end files from a same individual have been input following each other.\\
We first load the output of KisSplice. It is a fasta file that stores SNPs found in the data set.

<<snp_data, fig=FALSE>>=
fileIn <- system.file("extdata", "output_kissplice_SNP.fa", package = "kissDE")
exampleTable <- read.table(fileIn)
head(exampleTable, 4)
@

 By having a look a the 4 first lines, we can see that the fasta file is structurated as follows:
events are reported in 4 lines, the two first represent one allele of the SNP, the two last the other allele. Thus the sequences only differ from each other by their SNP content. The headers contain useful information:
\begin{itemize}
\item elements shared by the headers of the two alleles:
\begin{itemize}
  \item \texttt{bcc\_44787|Cycle\_421687} is the event's ID
  \item \texttt{Type\_0b} means that the sequences contains multiple SNPs, on the contrary \texttt{Type\_0a} is used for refering to single SNPs that could not be phased
  \item \texttt{upper\_path\_length\_131} and \texttt{lower\_path\_length\_131} give the length of the nucleotide sequences. They are the same for both alleles of a SNP (131 in this example). Upper path and lower path are a denomination for the representation of each allele in KisSplice's graph.
\end{itemize}
\item elements that are specific to an allele:
\begin{itemize}
  \item \texttt{C1\_455|C2\_455|C3\_839|C4\_848|C5\_5|C6\_0|C7\_39|C8\_31} summarizes the counts found by KisSplice during the step where reads are used to perform quantification of each variant detected. There are 8 counts because we input 8 files. Each count correspond to the reads coming from each file that could be mapped on the variant, in the order they have been passed to KisSplice. For instance, 455 reads from the first file (corresponding to one file of the pair of files from the first TSC individual) have been mapped on the first allele. This information is particularly important in kissDE since it represents the counts used for the test.
  \item The quality scores come after the counts for each read set following a \texttt{Q}.
\end{itemize}
\item NB: the rank is a deprecated measure.
\end{itemize}
The first step is to convert this fasta file into a format that will be used in kissDE's main function for testing. This can be done as follows:
<<snp_counts, fig=FALSE>>=
myCounts <- kissplice2counts(fileIn, pairedEnd=T)
names(myCounts)
head(myCounts$countsEvents)
@
We are in the casee of paired-end files, where a pair of file correspond to an individual. This information must be passed to the function so that counts from both files can be summed, with option \texttt{pairedEnd=T}.
In the result, we can see that the event's ID are used to label each event, and that an event is represented in two ines (one for each allele). The second column stores the size of the event, and all the next columns summarize the counts for each replicate. For instance, event \texttt{bcc\_44787|Cycle\_421687} already described previously has a length of 131, has 910 reads corresponding to its first TSC replicate (which correspond to the sum of the counts in \texttt{C1\_455|C2\_455}: 455 + 455 = 910, that have been realized thanks to \texttt{pairedEnd} option).

To be able to perform the differential analysis, we msut provide a vector that describes what is our experimental plan. In this example, we have two replicates of TSC and two replicates of EUR. So we construct a vector:
<<snp_condition, fig=FALSE>>=
myCondition <- c(rep("TSC",2), rep("EUR",2))
@
With this vector we can call the main function of the package that computes the statistical test. kissDE outputs a list of events that passed the p-value threshold:
<<snp_test, fig=FALSE>>=
myResult <- diffExpressedVariants(myCounts, myCondition)
head(myResult$finalTable)
@
\begin{itemize}
  \item \texttt{ID}: again we can spot an event using its ID. This time an event is represented by one row in the table.
  \item \texttt{Length\_diff}: not relevant for SNPs. 
  \item \texttt{Variant1\_EUR\_repl1\_Norm} and following columns: summarize the counts for each replicate of each variant after normalization with DESeq2. The first half represent the first allele of each event, the second half the second allele (the first allele is refered to as \texttt{Variant1} while the second is \texttt{Variant2}).
  \item \texttt{Adjusted\_pvalue}: corresponds to p-values computed and adjusted.
  \item \texttt{Deltaf/DeltaPSI}: summarizes the magnitude of the effect.
  \item \texttt{lowcounts}: flags low counts events as described in section[]. \texttt{FALSE} if the events has no low counts.
\end{itemize}
Events are sorted by p-values and then by magnitude of effect (based on their absolute values), so that the top candidates for further investigation/validation appear at the beginning of the list.

The event at the top of the list shows a low p-value (1.928149e-05) and a very contrasted $\Delta f$ (-0.9258) close to the maximum value (1 in absolute). Here we do not present biological conclusion because of the size of the sample that have been selected, which does not represent the real counts distribution. 



\subsection{kissDE on alternative splicing data}

The data used in this vignette to show an example of analysis of alternative splicing comes from ENCODE. The choosen samples are form a neuroblastoma cell line, SK-N-SH, with or without a retinoic acid treatment. Each conditions is composed of two biological replicates. The data are paired-end.\\
\kp has been used to analyse these two conditions. Then, the type 1 results from KisSplice were mapped to the reference genome with STAR and analyzed with KisSplice2refgenome. This tool allow the annotation of the alternative splicing events. It assigned each event to the gene it map to and to a type of alternative splicing event: Skipped Exon (SE), Intron Retention (IR), Alternatid Donor (AltD), Alternative Acceptor (AltA). For any question on these tools, please refer to the manual.

The first step is to load the output of KisSplice2refgenome. It is a tab delimited file that store the annotated alternative splicing events found in the dataset.

<<AS_data, fig=FALSE>>=
fileInAS <- system.file("extdata", "output_k2rg_alt_splicing.txt", package = "kissDE")
exampleK2RG <- read.table(fileInAS)
head(exampleK2RG, 3)
@

One line correspond to one alternative splicing event.
% explain the format ?

The \texttt{kissplice2count} function allow to transform this texte format into a format compatible with kissDE's main function for testing. The \texttt{k2rg} option must be set to \texttt{TRUE} to indicate that the file comes from KisSplice2refgenome and not from \kp. Like explained earlier, these samples are paired-end. This information must be given to the \texttt{kissplice2count} function.\\
The \texttt{counts} option must be set to the same value as in \kp and KisSplice2refgenome to indicate which counts are given in input. If \texttt{counts} is set to 0 (default value), total counts are used. If this option is set to 1, only junction counts are used. And if this option is set to 2, the detailed counts (AS, SB, AB, ASSB and S) are given. In this last case, the user can choose to use exonic reads (S counts) or not by set the \texttt{exonicReads} options to \texttt{TRUE}.

<<AS_counts, tidy=TRUE, highlight=FALSE, fig=FALSE>>=
myCountsAS <- kissplice2counts(fileInAS, pairedEnd = TRUE, k2rg = TRUE, 
                               counts = 2, exonicReads = FALSE)
names(myCountsAS)
head(myCountsAS$countsEvents)
@

The KisSplice2refgenome output contains the information of the type of splicing events. So it is possible to choose the event we want to analyse. The two options \texttt{keep} and \texttt{remove} allow the user to indicate the type of splicing events to analyse or to remove from the analysis. The events names should come from this list : deletion, insertion, IR, ES, altA, altD, altAD, alt, unclassified. By default, all types of events are analysed.\\
For example, if we only want to analyse the skipped exon events, the command to load the data is the following:
<<AS_ES_data, tidy=TRUE, highlight=FALSE, fig=FALSE>>=
myCountsES <- kissplice2counts(fileInAS, pairedEnd = TRUE, k2rg = TRUE, 
                               counts = 2, exonicReads = FALSE,
                               keep = c("ES"),remove = c("MULTI"))
names(myCountsES)
head(myCountsES$countsEvents)
@

To be able to perform the differential analysis, we must provide a vector that describes our experimental plan. In this example, we have two replicates of the SK-N-SH cell line without treatment (SKNSH) and two replicates of the same cell line treated with retinoic acid (SKSNH-RA). So we construct the following vector:
<<AS_condition, fig=FALSE>>=
myConditionAS <- c(rep("SKNSH",2), rep("SKNSH-RA",2))
@

With this vector we can call the main function of the package that computes the statistical test. kissDE outputs a list of events that passed the p-value threshold:
<<AS_test, fig=FALSE>>=
myResultAS <- diffExpressedVariants(myCountsAS, myConditionAS)
head(myResultAS$finalTable)
@

\begin{itemize}
  \item \texttt{ID}: again we can spot an event using its ID. This time an event is represented by one row in the table.
  \item \texttt{Length\_diff}: represent the difference of length between the upper and lower paths.
  \item \texttt{Variant1\_SKNSH\_repl1\_Norm} and following columns: summarize the counts for each replicate of each variant after normalization with DESeq2. The first half represent the first variant of each event, the second half the second variant.
  \item \texttt{Adjusted\_pvalue}: corresponds to p-values computed and adjusted.
  \item \texttt{Deltaf/DeltaPSI}: summarizes the magnitude of the effect.
  \item \texttt{lowcounts}: flags low counts events as described in section[]. \texttt{FALSE} if the events has no low counts.
\end{itemize}
Events are sorted by p-values and then by magnitude of effect (based on their absolute values), so that the top candidates for further investigation/validation appear at the beginning of the list.

The event at the top of the list shows a very low p-value (0) and a very contrasted $\Delta PSI$ (-0.8042) close to the maximum value (1 in absolute). Here we do not present biological conclusion because of the size of the sample that have been selected, which does not represent the real counts distribution. 

It is possible to output all the analysed events by setting the p-value threshold to 1:
<<AS_test_complete, fig=FALSE>>=
myResultAS_complete <- diffExpressedVariants(myCountsAS, myConditionAS, pvalue = 1)
tail(myResultAS_complete$finalTable)
@
The format of the result is the same as previously but the last events of this list are not significant (p-value > 0.05). Moreover, for some events, the $\Delta PSI$ is not computed because the counts are too low (\texttt{lowcounts} flag is set to \texttt{TRUE}).


\section{Session info}
Aurélie
% section biblio ?
\end{document}